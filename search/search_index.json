{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Compclasses","text":""},{"location":"#compclasses","title":"Compclasses","text":"<p>Like dataclasses, but for composition.</p> <p>Favor object composition over class inheritance</p> <p>As the Gang of Four (probably) said.</p> <p>However when we use composition in Python, we cannot access methods directly from the composed class, and we either re-define these methods from scratch, or access them using chaining.</p> <p>Compclasses enables composition and delegation of methods, making it easier to work with complex object structures.</p> <p>Documentation | Source Code</p>"},{"location":"#alpha-notice","title":"Alpha Notice","text":"<p>This codebase is experimental and is working for my use cases. It is very probable that there are cases not covered and for which everything breaks. If you find them, please feel free to open an issue in the issue page of the repo.</p>"},{"location":"#installation","title":"Installation","text":"<p>The library is dependency-free, it only uses built-in modules from the Python Standard Library.</p> <p>compclasses is published as a Python package on pypi, and it can be installed with pip, ideally by using a virtual environment (suggested option), or directly from source using git, or with a local clone:</p> pip (pypi)source/gitlocal clone <pre><code>python -m pip install compclasses\n</code></pre> <pre><code>python -m pip install git+https://github.com/FBruzzesi/compclasses.git\n</code></pre> <pre><code>git clone https://github.com/FBruzzesi/compclasses.git\ncd compclasses\npython -m pip install .\n</code></pre>"},{"location":"#license","title":"License","text":"<p>The project has a MIT Licence</p>"},{"location":"composition/","title":"Why Composition","text":""},{"location":"composition/#tldr","title":"TL;DR","text":"<p>Overall, composition is a more flexible and transparent way to reuse code and design classes in Python. It allows to build classes that are customized to your specific needs, and it promotes code reuse and modularity.</p>"},{"location":"composition/#composition-over-inheritance","title":"Composition over Inheritance","text":"<p>There are a few reasons why composition is generally preferred over inheritance in Python. Here a short list.</p>"},{"location":"composition/#flexibility","title":"Flexibility","text":"<p>Composition allows us to choose exactly which methods and attributes we want to include in our class, whereas inheritance requires to inherit the entire interface of the parent class. This allows us to design classes in a way that is tailored to specific needs.</p>"},{"location":"composition/#transparency","title":"Transparency","text":"<p>When using inheritance, it can be difficult to understand how a class is behaving, because it may be using methods and attributes from multiple ancestor classes.</p> <p>With composition, the behavior of a class is more transparent, as it is clear which methods and attributes are being used and from where they come from exactly.</p>"},{"location":"composition/#maintainability","title":"Maintainability","text":"<p>Inheritance can lead to complex class hierarchies and dependencies, which can make it difficult to maintain and modify the code.</p> <p>Composition, on the other hand, is easier to maintain since allows us to build classes using simple, independent components that are easy to understand and modify.</p>"},{"location":"composition/#code-reuse","title":"Code reuse","text":"<p>Composition promotes code reuse: instead of inheriting from a parent class and modifying its behavior, you can use composition to reuse code by encapsulating it in a separate class and composing it into your new class. This can make your code more modular and easier to reuse.</p>"},{"location":"composition/#rule-of-thumb","title":"Rule of Thumb","text":"<p>Overall, we can say that composition is a more flexible and transparent than inheritance. This doesn't mean that we should never use inheritance.</p> <p>As a rule of thumb, one can think to:</p> <ul> <li>Use composition if object <code>A</code> has a relationship with object <code>B</code> (e.g. a square has a side).</li> <li>Use inheritance if object <code>A</code> is a specification of object <code>B</code> (e.g. a square is a shape).</li> </ul> <p>One of the most common drawback of using composition is exactly the fact that methods/attributes provided by single components may have to be implemented again.</p>"},{"location":"composition/#resourcesreferences","title":"Resources/References","text":"<p>There are many resources where one can get a better understanding of why and when to prefer composition over inheritance:</p> <ul> <li>Wikipedia page</li> <li>Stack overflow discussion</li> <li>The perils of inheritance - by Ariel Ortiz</li> </ul>"},{"location":"contribute/","title":"Contributing","text":""},{"location":"contribute/#guidelines","title":"Guidelines","text":"<p>We welcome contributions to the library! If you have a bug fix or new feature that you would like to contribute, please follow the steps below:</p> <ol> <li>Fork the repository on GitHub.</li> <li>Clone the repository to your local machine.</li> <li>Create a new branch for your bug fix or feature.</li> <li>Make your changes and test them thoroughly, making sure that it passes all current tests.</li> <li>Commit your changes and push the branch to your fork.</li> <li>Open a pull request on the main repository.</li> </ol>"},{"location":"contribute/#code-of-conduct","title":"Code of Conduct","text":"<p>All contributors are expected to follow the project's code of conduct, which is based on the Contributor Covenant.</p>"},{"location":"contribute/#reporting-bugs","title":"Reporting Bugs","text":"<p>If you find a bug in the library, please report it by opening an issue on GitHub. Be sure to include the version of the library you're using, as well as any error messages or tracebacks and a reproducible example.</p>"},{"location":"contribute/#requesting-features","title":"Requesting Features","text":"<p>If you have a suggestion for a new feature, please open an issue on GitHub. Be sure to explain the problem that you're trying to solve and how you think the feature would solve it.</p>"},{"location":"contribute/#submitting-pull-requests","title":"Submitting Pull Requests","text":"<p>When submitting a pull request, please make sure that you've followed the steps above and that your code has been thoroughly tested. Also, be sure to include a brief summary of the changes you've made and a reference to any issues that your pull request resolves.</p>"},{"location":"contribute/#code-formatting","title":"Code formatting","text":"<p>Compclasses uses black and isort with default parameters for code formatting.</p> <p>As part of the checks on pull requests, it is checked whether the code follows those standards. To ensure that the standard is met, it is recommended to install pre-commit hooks:</p> <pre><code>python -m pip install pre-commit\npre-commit install\n</code></pre>"},{"location":"contribute/#developing","title":"Developing","text":"<p>Let's suppose that you already did steps 1-3 from the above list, now you should install the library and its developing dependencies  in editable way.</p> <p>First move into the repo folder: <code>cd compclasses</code>.</p> <p>Then:</p> with makewithout make <pre><code>make init-dev\n</code></pre> <pre><code>pip install -e \".[dev,doc]\" --no-cache-dir\npre-commit install\n</code></pre> <p>Now you are ready to proceed with all the changes you want to!</p>"},{"location":"contribute/#testing","title":"Testing","text":"<p>Once you are done with changes, you should:</p> <ul> <li>add tests for the new features in the <code>/tests</code> folder</li> <li> <p>make sure that new features do not break existing codebase by running tests:</p> with makewithout make <pre><code>make test\n</code></pre> <pre><code>rm -rf .pytest_cache\npytest tests -vv\nrm -rf .pytest_cache\n</code></pre> </li> </ul>"},{"location":"contribute/#docs","title":"Docs","text":"<p>The documentation is generated using mkdocs-material, the API part uses mkdocstrings.</p> <p>If a breaking feature is developed, then we suggest to update documentation in the <code>/docs</code> folder as well, in order to describe how this can be used from a user perspective.</p>"},{"location":"inspiration/","title":"Inspiration","text":""},{"location":"inspiration/#library","title":"Library","text":"<p>This projects is inspired by the forwardable library, a \"utility for easy object composition via delegation\".</p> <p>However I was looking for both more flexibility and more features. In particular:</p> <ul> <li>a clear separation between class definition and method forwarding;</li> <li>a validation step to make sure that changing something from the component doesn't break the class;</li> <li>the possibility to forward all the methods/attributes of a given component with a single instruction;</li> <li>the chance of adding prefix and/or suffix for each component;</li> </ul> <p>Please refer to Beyond the basics page to see example usages.</p>"},{"location":"inspiration/#docs","title":"Docs","text":"<p>Documentation style is inspired by FastAPI amazing docs.</p>"},{"location":"api/compclass/","title":"compclass (class decorator)","text":""},{"location":"api/compclass/#compclasses._decorator.compclass","title":"<code>compclass(_cls=None, delegates=None, verbose=True, log_func=logger.info)</code>","text":"<p>Decorator that adds class attributes/methods from <code>delegates</code> to <code>_cls</code> object as class properties.</p> <p>Parameters:</p> Name Type Description Default <code>_cls</code> <code>Union[Type[T], None]</code> <p>Class to which attributes/methods should be forwarded to.</p> <code>None</code> <code>delegates</code> <code>Union[Dict[str, Union[Iterable[str], delegatee]], None]</code> <p>Key-value pair of delegates.</p> <ul> <li>key: Name of the class/instance attribute to which the delegate instance is assigned to.</li> <li>value: Must be either a sequence/iterable of method names or a <code>delegatee</code> instance.     They represent the attributes/methods to forward.</li> </ul> <code>None</code> <code>verbose</code> <code>bool</code> <p>Defines the level of verbosity when setting those forwarded methods.</p> <code>True</code> <code>log_func</code> <code>Callable[[str], None]</code> <p>Function to use for logging, if verbose is set to True.</p> <code>info</code> <p>Raises:</p> Type Description <code>ValueError</code> <p><code>delegates</code> param cannot be <code>None</code>.</p> <p>Returns:</p> Type Description <code>Union[Type[T], Callable[[Type[T], Dict[str, Union[Iterable[str], delegatee]]], Type[T]]]</code> <p>Class with added methods from delegates.</p> <p>Usage:</p> <p>The function can be used as a class decorator:</p> <pre><code>class Foo:\n    a = 1\n\n    def __len__(self) -&gt; int:\n        # custom len method\n        return 42\n\n@compclass(delegates={\"_foo\": (\"a\", \"__len__\")})\nclass Bar:\n    def __init__(self, foo: Foo):\n        self._foo = foo\n\nfoo = Foo()\nbar = Bar(foo)\n\nbar.a  # -&gt; 1 (instead of bar._foo.a)\nlen(bar)  # -&gt; 42 (instead of len(bar._foo))\n</code></pre> Source code in <code>compclasses/_decorator.py</code> <pre><code>def compclass(\n    _cls: Union[Type[T], None] = None,\n    delegates: Union[Dict[str, Union[Iterable[str], delegatee]], None] = None,\n    verbose: bool = True,\n    log_func: Callable[[str], None] = logger.info,\n) -&gt; Union[Type[T], Callable[[Type[T], Dict[str, Union[Iterable[str], delegatee]]], Type[T]]]:\n    \"\"\"Decorator that adds class attributes/methods from `delegates` to `_cls` object as class properties.\n\n    Arguments:\n        _cls: Class to which attributes/methods should be forwarded to.\n        delegates: Key-value pair of delegates.\n\n            - key: Name of the class/instance attribute to which the delegate instance is assigned to.\n            - value: Must be either a sequence/iterable of method names or a `delegatee` instance.\n                They represent the attributes/methods to forward.\n\n        verbose: Defines the level of verbosity when setting those forwarded methods.\n        log_func: Function to use for logging, if verbose is set to True.\n\n    Raises:\n        ValueError: `delegates` param cannot be `None`.\n\n    Returns:\n        Class with added methods from delegates.\n\n    Usage:\n\n    The function can be used as a class decorator:\n\n    ```python\n    class Foo:\n        a = 1\n\n        def __len__(self) -&gt; int:\n            # custom len method\n            return 42\n\n    @compclass(delegates={\"_foo\": (\"a\", \"__len__\")})\n    class Bar:\n        def __init__(self, foo: Foo):\n            self._foo = foo\n\n    foo = Foo()\n    bar = Bar(foo)\n\n    bar.a  # -&gt; 1 (instead of bar._foo.a)\n    len(bar)  # -&gt; 42 (instead of len(bar._foo))\n    ```\n    \"\"\"\n    if delegates is None:\n        raise ValueError(\"`delegates` param cannot be `None`\")\n\n    def wrap(\n        _cls: Type[T],\n        delegates: Dict[str, Union[Iterable[str], delegatee]] = delegates,  # type: ignore\n    ) -&gt; Type[T]:\n        for _name, _to_inject in generate_properties(delegates, verbose, log_func):\n            setattr(_cls, _name, _to_inject)\n\n        return _cls\n\n    if _cls is None:\n        # Called with parens: @compclass(delegates=...)\n        return wrap\n\n    # Called directly on class C = compclass(C, delegates)\n    return wrap(_cls)\n</code></pre>"},{"location":"api/compclassmeta/","title":"CompclassMeta (metaclass)","text":""},{"location":"api/compclassmeta/#compclasses._meta.CompclassMeta","title":"<code>CompclassMeta</code>","text":"<p>             Bases: <code>ABCMeta</code></p> <p>Metaclass that adds class attributes/methods from <code>delegates</code> to <code>clsname</code> object as class properties.</p> <p>Usage:</p> <pre><code>class Foo:\n    a = 1\n\n    def __len__(self) -&gt; int:\n        # custom len method\n        return 42\n\nclass Bar(metacls=CompclassMeta, delegates={\"_foo\": (\"a\", \"__len__\")}):\n    def __init__(self, foo: Foo):\n        self._foo = foo\n\nfoo = Foo()\nbar = Bar(foo)\n\nbar.a  # -&gt; 1 (instead of bar._foo.a)\nlen(bar)  # -&gt; 42 (instead of len(bar._foo))\n</code></pre> Source code in <code>compclasses/_meta.py</code> <pre><code>class CompclassMeta(ABCMeta):\n    \"\"\"Metaclass that adds class attributes/methods from `delegates` to `clsname` object as class properties.\n\n    Usage:\n\n    ```python\n    class Foo:\n        a = 1\n\n        def __len__(self) -&gt; int:\n            # custom len method\n            return 42\n\n    class Bar(metacls=CompclassMeta, delegates={\"_foo\": (\"a\", \"__len__\")}):\n        def __init__(self, foo: Foo):\n            self._foo = foo\n\n    foo = Foo()\n    bar = Bar(foo)\n\n    bar.a  # -&gt; 1 (instead of bar._foo.a)\n    len(bar)  # -&gt; 42 (instead of len(bar._foo))\n    ```\n    \"\"\"\n\n    def __new__(\n        cls: Type,\n        clsname: str,\n        bases: Tuple[Type, ...],\n        attrs: Dict[str, Any],\n        delegates: Dict[str, Union[Iterable[str], delegatee]],\n        verbose: bool = True,\n        log_func: Callable[[str], None] = logger.info,\n    ) -&gt; CompclassMeta:\n        \"\"\"\n        Arguments:\n            cls: Metaclass\n            clsname: Class name\n            bases: Base classes\n            attrs: Class attributes\n            delegates: Key-value pair of delegates.\n\n                - key: Name of the class/instance attribute to which the delegate instance is assigned to.\n                - value: Must be either a sequence/iterable of method names or a `delegatee` instance.\n                    They represent the attributes/methods to forward.\n\n            verbose: Defines the level of verbosity when setting those forwarded methods.\n            log_func: Function to use for logging, if verbose is set to True.\n        \"\"\"\n\n        for _name, _to_inject in generate_properties(delegates, verbose, log_func):\n            attrs[_name] = _to_inject\n\n        return super().__new__(cls, clsname, bases, attrs)\n</code></pre>"},{"location":"api/compclassmeta/#compclasses._meta.CompclassMeta.__new__","title":"<code>__new__(clsname, bases, attrs, delegates, verbose=True, log_func=logger.info)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Type</code> <p>Metaclass</p> required <code>clsname</code> <code>str</code> <p>Class name</p> required <code>bases</code> <code>Tuple[Type, ...]</code> <p>Base classes</p> required <code>attrs</code> <code>Dict[str, Any]</code> <p>Class attributes</p> required <code>delegates</code> <code>Dict[str, Union[Iterable[str], delegatee]]</code> <p>Key-value pair of delegates.</p> <ul> <li>key: Name of the class/instance attribute to which the delegate instance is assigned to.</li> <li>value: Must be either a sequence/iterable of method names or a <code>delegatee</code> instance.     They represent the attributes/methods to forward.</li> </ul> required <code>verbose</code> <code>bool</code> <p>Defines the level of verbosity when setting those forwarded methods.</p> <code>True</code> <code>log_func</code> <code>Callable[[str], None]</code> <p>Function to use for logging, if verbose is set to True.</p> <code>info</code> Source code in <code>compclasses/_meta.py</code> <pre><code>def __new__(\n    cls: Type,\n    clsname: str,\n    bases: Tuple[Type, ...],\n    attrs: Dict[str, Any],\n    delegates: Dict[str, Union[Iterable[str], delegatee]],\n    verbose: bool = True,\n    log_func: Callable[[str], None] = logger.info,\n) -&gt; CompclassMeta:\n    \"\"\"\n    Arguments:\n        cls: Metaclass\n        clsname: Class name\n        bases: Base classes\n        attrs: Class attributes\n        delegates: Key-value pair of delegates.\n\n            - key: Name of the class/instance attribute to which the delegate instance is assigned to.\n            - value: Must be either a sequence/iterable of method names or a `delegatee` instance.\n                They represent the attributes/methods to forward.\n\n        verbose: Defines the level of verbosity when setting those forwarded methods.\n        log_func: Function to use for logging, if verbose is set to True.\n    \"\"\"\n\n    for _name, _to_inject in generate_properties(delegates, verbose, log_func):\n        attrs[_name] = _to_inject\n\n    return super().__new__(cls, clsname, bases, attrs)\n</code></pre>"},{"location":"api/delegatee/","title":"delegatee","text":""},{"location":"api/delegatee/#compclasses._delegatee.delegatee","title":"<code>delegatee</code>","text":"<p>Delegatee class, used in place of an iterable when defining delegates dictionary.</p> <p>This class provides the following features:</p> <ul> <li>It allows to validate the delegatee class attributes/methods.</li> <li>It supports the \"*\" argument in attrs parameter, which automatically detects all non-dunder methods of the     delegatee class.</li> <li>It enables adding prefix and/or suffix to non-dunder methods.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>delegatee_cls</code> <code>Type</code> <p>Class from which we delegate. This is the class/type definition, no need to instantiate it.</p> required <code>attrs</code> <code>Iterable[str]</code> <p>Sequence of attributes/methods to inject on the composed class.</p> <p>Warning</p> <p>If <code>\"*\"</code> is present, we inject all the methods, excluding dunder methods, which need to be explicitly stated.</p> required <code>prefix</code> <code>str</code> <p>Injected methods prefix, unused for dunder methods.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>Injected methods suffix, unused for dunder methods.</p> <code>''</code> <code>validate</code> <code>bool</code> <p>Whether or not to validate if <code>delegatee_cls</code> has all the methods and/or attributes.</p> <p>Warning</p> <ul> <li>Methods are searched in class definition <code>__dict__</code>.</li> <li>Attributes are searched in class <code>__init__</code> code by matching the following regex:     <code>\"self.{attr}\"</code> (more technically, <code>re.compile(r\"self.(\\w+)\")</code>).</li> </ul> <code>True</code> <p>Methods:</p> Name Description <code>- _parse_attrs</code> <p>Parses the original attrs sequence, splitting between dunder and class methods.</p> <code>- _is_dunder_method</code> <p>Assess whether or not an attribute is a dunder method.</p> <code>- _validate_delegatee_methods</code> <p>Checks if delegatee_cls has all attributes/methods in attrs.</p> Source code in <code>compclasses/_delegatee.py</code> <pre><code>class delegatee:\n    \"\"\"Delegatee class, used in place of an iterable when defining delegates dictionary.\n\n    This class provides the following features:\n\n    - It allows to validate the delegatee class attributes/methods.\n    - It supports the \"*\" argument in attrs parameter, which automatically detects all non-dunder methods of the\n        delegatee class.\n    - It enables adding prefix and/or suffix to non-dunder methods.\n\n    Arguments:\n        delegatee_cls: Class from which we delegate. This is the class/type definition, no need to instantiate it.\n        attrs: Sequence of attributes/methods to inject on the composed class.\n            !!! warning\n                If `\"*\"` is present, we inject all the methods, **excluding** dunder methods, which need to be\n                explicitly stated.\n        prefix: Injected methods prefix, unused for dunder methods.\n        suffix: Injected methods suffix, unused for dunder methods.\n        validate: Whether or not to validate if `delegatee_cls` has all the methods and/or attributes.\n\n            !!! warning\n                - Methods are searched in class definition `__dict__`.\n                - Attributes are searched in class `__init__` code by matching the following regex:\n                    `\"self.{attr}\"` (more technically, `re.compile(r\"self.(\\w+)\")`).\n\n    Methods:\n        - _parse_attrs: Parses the original attrs sequence, splitting between dunder and class methods.\n        - _is_dunder_method: Assess whether or not an attribute is a dunder method.\n        - _validate_delegatee_methods: Checks if delegatee_cls has all attributes/methods in attrs.\n    \"\"\"\n\n    def __init__(\n        self,\n        delegatee_cls: Type,\n        attrs: Iterable[str],\n        prefix: str = \"\",\n        suffix: str = \"\",\n        validate: bool = True,\n    ):\n        if not attrs:  # empty iterable such as list(), tuple(), None, etc...\n            raise ValueError(\"attrs parameter cannot be None\")\n\n        self.delegatee_cls = delegatee_cls\n\n        if delegatee_cls is not None:\n            self._attrs = self._parse_attrs(delegatee_cls, attrs)\n        else:\n            self._attrs = tuple(attrs)\n\n        if validate and (delegatee_cls is not None):\n            self._validate_delegatee_methods(self.delegatee_cls, self._attrs)\n\n        self._prefix = prefix\n        self._suffix = suffix\n\n    def __iter__(self):\n        for attr_name in self._attrs:\n            yield attr_name\n\n    @staticmethod\n    def _parse_attrs(delegatee_cls: Type, attrs: Iterable[str]) -&gt; Tuple[str, ...]:\n        \"\"\"Parses the original attrs sequence:\n\n        - Splits between dunder and class methods.\n        - If `\"*\"` is present, we add all the methods to the list of methods to inject, excluding dunder methods which\n            need to be explicitly stated.\n        - If `\"*\"` is not present, we simply return the original attrs sequence.\n        \"\"\"\n\n        dunder_methods, base_methods = partition(delegatee._is_dunder_method, attrs)\n        if \"*\" in base_methods:\n            pattern = re.compile(r\"self.(\\w+)\")\n\n            methods = tuple(\n                attr_name for attr_name in delegatee_cls.__dict__.keys() if not delegatee._is_dunder_method(attr_name)\n            )\n            try:\n                co_code = inspect.getsource(delegatee_cls.__init__)\n                init_attrs = tuple(pattern.findall(co_code))\n\n            except Exception as e:\n                logger.info(f\"Unable to parse __init__ method of {delegatee_cls} due to: {e}\")\n                init_attrs = tuple()\n\n            all_methods = methods + init_attrs\n        else:\n            all_methods = base_methods\n        return dunder_methods + all_methods\n\n    @staticmethod\n    def _is_dunder_method(attr_name: str) -&gt; bool:\n        \"\"\"Assesses whether or not `attr_name` is a dunder method by checking if it startsand ends with \"__\".\"\"\"\n        return attr_name.startswith(\"__\") and attr_name.endswith(\"__\")\n\n    @staticmethod\n    def _validate_delegatee_methods(delegatee_cls: Type, attrs: Iterable[str]) -&gt; None:\n        \"\"\"Checks if `delegatee_cls` has all attributes and methods listed in attrs.\n\n        Arguments:\n            delegatee_cls: Class from which we delegate. This is the class definition, no need to instantiate it.\n            attrs: Sequence of attributes/methods to inject on the composed class.\n\n        Raises:\n            AttributeError: if `delegatee_cls` has no attribute/method in attrs.\n        \"\"\"\n\n        cls_methods = tuple([a[0] for a in inspect.getmembers(delegatee_cls)])\n\n        try:\n            co_code = inspect.getsource(delegatee_cls.__init__)\n            pattern = re.compile(r\"self.(\\w+)\")\n            init_attrs = tuple(pattern.findall(co_code))\n\n        except Exception as e:\n            logger.info(f\"Unable to parse `__init__` method of {delegatee_cls} due to error: {e}\")\n            init_attrs = tuple()\n\n        all_methods = cls_methods + init_attrs\n        for attr_name in attrs:\n            if attr_name not in all_methods:\n                raise AttributeError(f\"'{delegatee_cls}' has no attribute nor method '{attr_name}'\")\n</code></pre>"},{"location":"user_guide/beyond_basics/","title":"Beyond the basics","text":""},{"location":"user_guide/beyond_basics/#delegatee-class","title":"delegatee class","text":"<p>Instead of using an iterable in the <code>delegates</code> dictionary, it is possible to pass a delegatee instance as a value.</p> <p>This will yield more flexibility and features when decide to forward class attributes and methods.</p> <p>Let's see in detail which features are currently available.</p>"},{"location":"user_guide/beyond_basics/#features","title":"Features","text":""},{"location":"user_guide/beyond_basics/#attributes-and-methods-validation","title":"Attributes and methods validation","text":"<p>When using <code>delegatee</code> class we have the option to check whether or not attributes and methods are present in the class.</p> <p>If we do so (<code>validate=True</code> parameter), then an <code>AttributeError</code> is raised if the attribute/method is not found in the class definition.</p> <p>Remark that we check for:</p> <ul> <li>class attributes and methods;</li> <li>instance attributes assigned in the <code>__init__</code> method, by parsing the <code>__init__</code> code and look for <code>self.attr_name = ...</code> syntax.</li> </ul> <p>Why should you check if an attribute/method is present?</p> <p>A validation step makes sure that changing something from the component class doesn't break the class using the given component somewhere down the rabbit hole, but it gets detected as soon as possible.</p>"},{"location":"user_guide/beyond_basics/#the-star-argument","title":"The \"star\" argument","text":"<p>Sometimes you want to forward all the methods of a given class. To accomplish that, it is enough to pass <code>attrs=[\"*\"]</code> to the <code>delegatee</code> class.</p> <p>Doing so will parse and add all the class attributes, methods and instance attributes of the <code>delegatee_cls</code> to the composed class.</p> <p>This gives the possibility to forward all the methods/attributes of a component with a single instruction.</p> <p>Warning</p> <p>Dunder methods and instance attributes are not forwarded unless explicitly specified in the <code>attrs</code> parameter.</p>"},{"location":"user_guide/beyond_basics/#custom-prefix-suffix","title":"Custom prefix &amp; suffix","text":"<p>It is also possible to specify custom prefix and/or suffix for each component. The default behaviour is to call it as in the delegatee class, but it is possible to change that.</p> <p>Warning</p> <p>Dunder methods ignore the prefix and suffix parameters.</p>"},{"location":"user_guide/beyond_basics/#verbosity","title":"Verbosity","text":"<p><code>compclass</code> and <code>CompclassMeta</code> accept a <code>verbose</code> parameter which defines the level of verbosity when setting those forwarded methods.</p> <p>If the value is <code>True</code> then we explicitly \"declare\" each forwarded method/attribute.</p>"},{"location":"user_guide/beyond_basics/#examples","title":"Examples","text":"<p>As in the previous section let's define the <code>Foo</code> and <code>Bar</code> classes:</p> classes definition<pre><code>class Foo:\n    \"\"\"Foo class\"\"\"\n\n    def __init__(self, value: int):\n        \"\"\"foo init\"\"\"\n        self._value = value\n\n    def get_value(self):\n        \"\"\"get value attribute\"\"\"\n        return self._value\n\n    def hello(self, name: str) -&gt; str:\n        \"\"\"Method with argument\"\"\"\n        return f\"Hello {name}, this is Foo!\"\n\n\nclass Bar:\n    \"\"\"Bar class\"\"\"\n    b: int = 1\n\n    def __len__(self) -&gt; int:\n        \"\"\"Custom len method\"\"\"\n        return 42\n</code></pre> <p>Now instead of using a list of attribute/methods name, let's define delegates using <code>delegatee</code> class, with few extra params:</p> delegatee class<pre><code>from compclasses import compclass, delegatee\n\ndelegates = {\n    \"_foo\": delegatee(\n        delegatee_cls=Foo,  # class definition of the _foo instance\n        attrs=(\"*\", ),  # list of attributes/methods to forward\n        suffix=\"_from_foo\"  # let's add a prefix to distinguish from where the method is forwarded, this can be any string\n        ),\n    \"_bar\": delegatee(\n        delegatee_cls=Bar,\n        attrs=(\"__len__\", \"b\"),\n        validate=True,  # we want to validate that Bar class has \"__len__\" method and \"b\" attribute\n        prefix=\"bar_\"  # let's add a prefix to distinguish from where the method is forwarded, this can be any string\n        )\n}\n\n@compclass(\n    delegates=delegates,\n    verbose=True  # verbisity level to use\n)\nclass Baz:\n    \"\"\"Baz class\"\"\"\n\n    def __init__(self, foo: Foo, bar: Bar):\n        self._foo = foo\n        self._bar = bar\n\n# Unable to parse __init__ method of &lt;class '__main__.Bar'&gt; due to the following reason: module, class, method, function, traceback, frame, or code object was expected, got wrapper_descriptor\n# Setting get_value_from_foo from _foo.get_value\n# Setting hello_from_foo from _foo.hello\n# Setting _value_from_foo from _foo._value\n# Setting __len__ from _bar.__len__\n# Setting bar_b from _bar.b\n</code></pre> <p>Let's see what is happening here:</p> <ul> <li><code>Bar</code>'s <code>delegatee</code> have <code>validate=True</code> param, therefore checks <code>__len__</code> and <code>b</code> are presents. While doing so it fails to find an <code>__init__</code> method (this is an implementation detail of the class <code>object</code> implemented in C). Notice that however this does not raise an error. It would have if any of <code>__len__</code> or <code>b</code> were not found.</li> <li>Passing <code>attrs=(\"*\", )</code> for <code>Foo</code> allows to forward all non-dunder methods of <code>Foo</code> to <code>Baz</code>, namely <code>get_value</code>, <code>hello</code> and <code>_value</code> (this last one is found in <code>Foo.__init__</code>).</li> <li>Since we are using a suffix, the new methods in <code>Baz</code> are called <code>get_value_from_foo</code>, <code>hello_from_foo</code> and <code>_value_from_foo</code>.</li> <li>Similarly we use a prefix in <code>Bar</code> delegatee, hence <code>b</code> becomes <code>bar_b</code>, yet <code>__len__</code> is forwarded as-is.</li> </ul> <p>Let's now see what happens if a class attribute or an undefined method is passed in the <code>attrs</code> list:</p> validating attributes/methods<pre><code>delegatee(delegatee_cls=Foo, attrs=(\"_value\",))\ndelegatee(delegatee_cls=Foo, attrs=(\"some_fake_method\",))\n</code></pre> <p>(...) AttributeError: '' has no attribute nor method 'some_fake_method' <p>In the first case, <code>_value</code> attribute can be detected from the <code>__init__</code> method as we saw above already.</p> <p>For the latter case, it is clear that the method is not present in the class definition, and an error is raised.</p>"},{"location":"user_guide/getting_started/","title":"Getting Started","text":""},{"location":"user_guide/getting_started/#introduction","title":"Introduction","text":"<p>Let's suppose we have the following 3 classes, <code>Foo</code>, <code>Bar</code> and <code>Baz</code>:</p> <ul> <li><code>Foo</code> and <code>Bar</code> are independent from one another;</li> <li><code>Baz</code> get initialized with two class attributes (<code>_foo</code>, <code>_bar</code>) which are instances of the other two classes.</li> </ul> Classes definition<pre><code>class Foo:\n    \"\"\"Foo class\"\"\"\n\n    def __init__(self, value: int):\n        \"\"\"foo init\"\"\"\n        self._value = value\n\n    def get_value(self):\n        \"\"\"get value attribute\"\"\"\n        return self._value\n\n    def hello(self, name: str) -&gt; str:\n        \"\"\"Method with argument\"\"\"\n        return f\"Hello {name}, this is Foo!\"\n\n\nclass Bar:\n    \"\"\"Bar class\"\"\"\n    b: int = 1\n\n    def __len__(self) -&gt; int:\n        \"\"\"Custom len method\"\"\"\n        return 42\n\nclass Baz:\n    \"\"\"Baz class\"\"\"\n\n    def __init__(self, foo: Foo, bar: Bar):\n        self._foo = foo\n        self._bar = bar\n</code></pre> <p>Now let's instantiate them and try see how we would access the \"inner\" attributes/methods:</p> Naive approach<pre><code>foo = Foo(123)\nbar = Bar()\n\nbaz = Baz(foo, bar)\n\nbaz._foo.get_value()  # -&gt; 123\nbaz._foo.hello(\"GitHub\")  # -&gt; \"Hello GitHub, this is Foo!\"\nbaz._bar.__len__()  # -&gt; 42\n\nlen(baz)  # -&gt; TypeError: object of type 'Baz' has no len()\n</code></pre>"},{"location":"user_guide/getting_started/#compclass-decorator","title":"compclass (decorator)","text":"<p>Using the compclass decorator we can forward the methods that we want to the <code>Baz</code> class from its attributes at definition time:</p> Using compclass<pre><code>from compclasses import compclass\n\ndelegates = {\n    \"_foo\": ( \"get_value\", \"hello\"),\n    \"_bar\": (\"__len__\", )\n}\n\n@compclass(delegates=delegates)\nclass Baz:\n    \"\"\"Baz class\"\"\"\n\n    def __init__(self, foo: Foo, bar: Bar):\n        self._foo = foo\n        self._bar = bar\n\nbaz = Baz(foo, bar)\nbaz.get_value()  # -&gt; 123\nbaz.hello(\"GitHub\")  # -&gt; \"Hello GitHub, this is Foo!\"\nlen(baz)  # -&gt; 42\n</code></pre> <p>We can see how now we can access the methods directly.</p> <p>Remark that in the <code>delegates</code> dictionary, we have that:</p> <ul> <li>the keys correspond to the attribute names in the <code>Baz</code> class;</li> <li>each value should be an iterable of string corresponding to methods/attributes present in the class instance associated to the key-attribute.</li> </ul> <p>The <code>compclass</code> decorator adds each attribute and method as a property attribute, callable as <code>self.&lt;attr_name&gt;</code> instead of <code>self.&lt;delegatee_cls&gt;.&lt;attr_name&gt;</code></p>"},{"location":"user_guide/getting_started/#compclassmeta-metaclass","title":"CompclassMeta (metaclass)","text":"<p>The equivalent, but alternative, way of doing it is by using the <code>CompclassMeta</code> metaclass when you define the class.</p> Using CompclassMeta<pre><code>from compclasses import CompclassMeta\n\ndelegates = {\n    \"_foo\": ( \"get_value\", \"hello\"),\n    \"_bar\": (\"__len__\", )\n}\n\nclass Baz(metaclass=CompclassMeta, delegates=delegates):\n    \"\"\"Baz class\"\"\"\n\n    def __init__(self, foo: Foo, bar: Bar):\n        self._foo = foo\n        self._bar = bar\n\nbaz = Baz(foo, bar)\nbaz.get_value()  # -&gt; 123\nbaz.hello(\"GitHub\")  # -&gt; \"Hello GitHub, this is Foo!\"\nlen(baz)  # -&gt; 42\n</code></pre> <p>As you can see the syntax is nearly one-to-one with the <code>compclass</code> decorator, and the resulting behaviour is exactly the same!</p>"},{"location":"user_guide/getting_started/#next-steps","title":"Next Steps","text":"<p>Instead of using an iterable in the <code>delegates</code> dictionary, we suggest to use a delegatee instance as a value.</p> <p>This will yield more flexibility and features when decide to forward class attributes and methods.</p> <p>In the next section we will do a deep dive into what these features are, how to use them and their pros and cons.</p>"},{"location":"user_guide/integration/","title":"Integration with Pydantic and dataclasses","text":"<p>Integrating with Pydantic and dataclasses can be beneficial for leveraging the powerful features provided by these libraries while also enjoying the flexibility and ease of use offered by composition.</p> <p>Integration is possible and seamless, as Compclasses is designed to be compatible with both.</p> <p>Let's see how this integration would work in practice.</p> <p>First let's define the <code>Foo</code> and <code>Bar</code> classes:</p> classes definition<pre><code>class Foo:\n    \"\"\"Foo class\"\"\"\n\n    def __init__(self, value: int):\n        \"\"\"foo init\"\"\"\n        self._value = value\n\n    def get_value(self):\n        \"\"\"get value attribute\"\"\"\n        return self._value\n\n    def hello(self, name: str) -&gt; str:\n        \"\"\"Method with argument\"\"\"\n        return f\"Hello {name}, this is Foo!\"\n\n    def __repr__(self) -&gt; str:\n        return f\"Foo({self._value})\"\n\n\nclass Bar:\n    \"\"\"Bar class\"\"\"\n    b: int = 1\n\n    def __len__(self) -&gt; int:\n        \"\"\"Custom len method\"\"\"\n        return 42\n    def __repr__(self) -&gt; str:\n        return \"baaarepr\"\n\nfoo = Foo(123)\nbar = Bar()\n\ndelegates = {\n    \"foo\": ( \"get_value\", \"hello\"),\n    \"bar\": (\"__len__\", )\n}\n</code></pre>"},{"location":"user_guide/integration/#pydantic","title":"Pydantic","text":"<p>Pydantic is a popular library for data validation and parsing, which allows you to define data models using Python annotations. Pydantic provides automatic validation and conversion of data based on the defined models, while Compclasses enables composition and delegation of methods, making it easier to work with complex object structures.</p> <p>The integration with Pydantic can be done by using the compclass decorator, which will create a new class inheriting from the Pydantic <code>BaseModel</code> class, and will add the methods defined in the <code>delegates</code> dictionary.</p> Pydantic integration<pre><code>from compclasses import compclass\nfrom pydantic import BaseModel\n\n@compclass(delegates=delegates, verbose=False)\nclass Baz(BaseModel):\n    \"\"\"Baz class\"\"\"\n    foo: Foo\n    bar: Bar\n\n    class Config:\n        arbitrary_types_allowed = True\n\nbaz = Baz(foo=foo, bar=bar)\nbaz, len(baz), baz.get_value(), baz.hello(\"there\")\n# (Baz(foo=Foo(123), bar=baaarepr), 42, 123, 'Hello there, this is Foo!')\n</code></pre> <p>On the other hand using the CompclassMeta metaclass will result in the following error:</p> <p>TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases</p>"},{"location":"user_guide/integration/#dataclasses","title":"Dataclasses","text":"<p>Dataclasses are a Python built-in module that provides a concise syntax for defining classes with automatic generation of common methods. By integrating Compclasses with dataclasses, you can enhance the functionality and extensibility of your dataclasses.</p> <p>The integration with dataclasses can be done by using both compclass decorator and CompclassMeta metaclass:</p> dataclass + compclassdataclass + CompclassMeta <pre><code>from compclasses import compclass\nfrom dataclasses import dataclass\n\n@dataclass\n@compclass(delegates=delegates, verbose=False)\nclass Baz:\n    \"\"\"Baz class\"\"\"\n    foo: Foo\n    bar: Bar\n\nbaz = Baz(foo=foo, bar=bar)\nbaz, len(baz), baz.get_value(), baz.hello(\"there\")\n# (Baz(foo=Foo(123), bar=baaarepr), 42, 123, 'Hello there, this is Foo!')\n</code></pre> <pre><code>from compclasses import CompclassMeta\nfrom dataclasses import dataclass\n\n@dataclass\nclass Baz(metaclass=CompclassMeta, delegates=delegates, verbose=False):\n    \"\"\"Baz class\"\"\"\n    foo: Foo\n    bar: Bar\n\nbaz = Baz(foo=foo, bar=bar)\nbaz, len(baz), baz.get_value(), baz.hello(\"there\")\n# (Baz(foo=Foo(123), bar=baaarepr), 42, 123, 'Hello there, this is Foo!')\n</code></pre>"},{"location":"user_guide/mypy/","title":"MyPy Compliance","text":""},{"location":"user_guide/mypy/#the-problem","title":"The problem","text":"<p>For those who follow the mypy religion, I hear you! I do too!</p> <p>And adding methods/attributes dynamically will make MyPy complain and scream at you:</p> <pre><code>from compclasses import CompclassMeta\n\nclass Foo:\n    \"\"\"Foo class\"\"\"\n\n    _value: int = 1\n\n    def get_value(self):\n        \"\"\"get value attribute\"\"\"\n        return self._value\n\nclass Baz(metaclass=CompclassMeta, delegates={\"_foo\": (\"_value\", \"get_value\")}):\n    \"\"\"Baz class\"\"\"\n\n    def __init__(self, foo: Foo):\n        self._foo = foo\n\n\nbaz = Baz(foo=Foo())\nbaz._value  # error: \"Baz\" has no attribute \"_value\"\nbaz.get_value()  # error: \"Baz\" has no attribute \"get_value\"\n</code></pre> <p>There are at least two ways to make mypy quiet about this.</p>"},{"location":"user_guide/mypy/#solutions","title":"Solutions","text":""},{"location":"user_guide/mypy/#make-a-promise","title":"Make a promise","text":"<p>You can make a promise to mypy in the class definition that such attribute/method will exist even without defining it directly: <pre><code>from typing import Callable\n\nclass Baz(metaclass=CompclassMeta, delegates={\"_foo\": (\"_value\", \"get_value\")}):\n    \"\"\"Baz class\"\"\"\n\n    _value: int\n    get_value: Callable\n\n    def __init__(self, foo: Foo):\n        self._foo = foo\n\nbaz = Baz(foo=Foo())\nbaz._value\nbaz.get_value()\n</code></pre></p> <p>This can be annoying, especially when adding a suffix and/or a prefix, however will give you the best results from your IDE.</p>"},{"location":"user_guide/mypy/#type-ignore","title":"type: ignore","text":"<p>This is the dirty way which saves you when you are kind of desperate (let's be honest!):</p> <pre><code>class Baz(metaclass=CompclassMeta, delegates={\"_foo\": (\"_value\", \"get_value\")}):\n    \"\"\"Baz class\"\"\"\n\n    def __init__(self, foo: Foo):\n        self._foo = foo\n\nbaz = Baz(foo=Foo())\nbaz._value  # type: ignore\nbaz.get_value()  # type: ignore\n</code></pre>"}]}